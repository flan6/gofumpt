exec gofumpt -w foo.go
cmp foo.go foo.go.golden

exec gofumpt -d foo.go.golden
! stdout .

-- foo.go --
package p

func f() {
	if true {

		println()
		println()

		println()
	}

	for true {
		println()
		println()

		println()

	}

	{


		println(1, 2,
			3, 4, `foo
			bar`)

		println(1, 2,
			3, 4, `foo
			bar`)



	}

	{

		// comment directly before
		println()
		println()

		println()

		// comment after

	}

	{

		// comment before

		println()
		println()

		println()
		// comment directly after

	}

	// For readability; the empty line helps separate the multi-line
	// condition from the body.
	if true &&
		true {

		println()
		println()

		println()
	}
	if true &&
		true {
		println()
		println()

		println()

	} else if true {
		println()
		println()

		println()
	}
	for true &&
		true {

		println()
		println()

		println()
	}
	if true &&
		true {

		// documented multi statement
		println()
		println()

		println()
	}
}
-- foo.go.golden --
package p

func f() {
	if true {
		println()
		println()

		println()
	}

	for true {
		println()
		println()

		println()
	}

	{
		println(1, 2,
			3, 4, `foo
			bar`)

		println(1, 2,
			3, 4, `foo
			bar`)
	}

	{
		// comment directly before
		println()
		println()

		println()

		// comment after
	}

	{
		// comment before

		println()
		println()

		println()
		// comment directly after
	}

	// For readability; the empty line helps separate the multi-line
	// condition from the body.
	if true &&
		true {

		println()
		println()

		println()
	}
	if true &&
		true {
		println()
		println()

		println()

	} else if true {
		println()
		println()

		println()
	}
	for true &&
		true {

		println()
		println()

		println()
	}
	if true &&
		true {

		// documented multi statement
		println()
		println()

		println()
	}
}
